## Longest common subsequence  


step 1：优先检查特殊情况。  

step 2：获取最长公共子序列的长度可以使用动态规划，我们以dp[i][j]dp[i][j]dp[i][j]表示在s1中以iii结尾，s2中以jjj结尾的字符串的最长公共子序列长度。  

step 3：遍历两个字符串的所有位置，开始状态转移：若是iii位与jjj位的字符相等，则该问题可以变成1+dp[i−1][j−1]1+dp[i-1][j-1]1+dp[i−1][j−1]，即到此处为止最长公共子序列长度由前面的结果加1。  

step 4：若是不相等，说明到此处为止的子串，最后一位不可能同时属于最长公共子序列，毕竟它们都不相同，  
因此我们考虑换成两个子问题，dp[i][j−1]dp[i][j-1]dp[i][j−1]或者dp[i−1][j]dp[i-1][j]dp[i−1][j]，我们取较大的一个就可以了，由此感觉可以用递归解决。  

step 5：但是递归的复杂度过高，重复计算了很多低层次的部分，因此可以用动态规划，从前往后加，由此形成一个表，表从位置1开始往后相加，正好符合动态规划的转移特征。  

step 6：因为最后要返回该序列，而不是长度，所以在构造表的同时要以另一个二维矩阵记录上面状态转移时选择的方向，我们用1表示来自左上方，2表示来自左边，3表示来自上边。  

step 7：获取这个序列的时候，根据从最后一位开始，根据记录的方向，不断递归往前组装字符，只有来自左上的时候才添加本级字符，因为这种情况是动态规划中两个字符相等的情况，字符相等才可用。    

## dp数组: dp[i][j]表示第一个字符串到第i位，第二个字符串到第j位为止的最长公共子序列长度  

<img src="https://github.com/cn666278/Java-Project/blob/main/LongestCommonSubsequence/dp%5Bi%5D%5Bj%5D.png" height="70%" width="80%">  

## b数组: 用于记录动态规划数组相加的方向  
### 用1表示来自左上方，2表示来自上边，3表示来自左边。  

<img src="https://github.com/cn666278/Java-Project/blob/main/LongestCommonSubsequence/b%5Bi%5D%5Bj%5D.png" height="70%" width="80%">
